<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mar_明的博客</title>
  
  
  <link href="https://marming19.github.io/atom.xml" rel="self"/>
  
  <link href="https://marming19.github.io/"/>
  <updated>2020-12-30T10:31:39.073Z</updated>
  <id>https://marming19.github.io/</id>
  
  <author>
    <name>Mar_明</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Art虚拟机之dex文件加载</title>
    <link href="https://marming19.github.io/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/"/>
    <id>https://marming19.github.io/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/</id>
    <published>2020-12-28T07:50:15.000Z</published>
    <updated>2020-12-30T10:31:39.073Z</updated>
    
    <content type="html"><![CDATA[<p>之前dalvik与Art上虚拟机的代码都看过，但是长时间不看就忘了，所有在此进行记录下。这里以Android6.0.1-r1的源码进行分析。<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-1.png" alt="image-1"></p><a id="more"></a><p>可以看到直接调用了BaseDexClassLoader的构造函数<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-2.png" alt="image-2"><br>可以看到，在构造函数中new了一个DexpathList并赋值给pathList<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-3.png" alt="image-3"><br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-4.png" alt="image-4"><br>可以看到 DexpathList中开始对参数进行校验，然后调用makePathElements函数构建Element数组，然后赋值给dexElements，继续往下看这个函数还调用makePathElements构建Element数组，赋值给nativeLibraryPathElements，动态库存在的路径，下面我们先看下Element对象<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-5.png" alt="image-5"><br>可以看到Element中存放着一个DexFile，下面我们回到makePathElements函数，<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-6.png" alt="image-6"><br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-7.png" alt="image-7"><br>可以看到，如果传入的文件为dex，则会调用loadDexFile函数进行加载，然后返回DexFile对象存放到Element中。<br>继续看下loadDexFile<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-8.png" alt="image-8"><br>在看下loadDex函数<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-9.png" alt="image-9"><br>内部直接new了一个DexFile对象，在看下DexFile构造函数<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-10.png" alt="image-10">这里看到构造函数内部调用openDexFile函数进行加载，并将返回值，赋值给了mCookie，看到mCookie就知道，这是早期的一个脱壳点，mCookie对应的是内存中dex的地址<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-11.png" alt="image-11"><br>最后调用到了openDexFileNative函数，这是一个native方法，下面我们进入native层看下具体实现。<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-12.png" alt="image-12"><br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-13.png" alt="image-13"><br>从函数中可以看出来，主要的加载过程是在OpenDexFilesFromOat函数中实现的，执行完成后会把结果放入到DexFile数组中。<br>下面看下函数具体实现<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-14.png" alt="image-14"><br>首先看下 构造了一个aot_file_assistant，主要是协助dex文件解析成oat文件，其构造函数内部只是简单做了初始化。<br>首先是从oat_files_中查找是否已经加载了oat文件<br>如果不存在会调用MakeUpToDate(),GetBestOatFile()函数从本地查找oat文件<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-16.png" alt="image-16"><br>在这里可以看到，如果是第一次加载dex文件的话，GetDexOptNeeded()函数会返回kDex2OatNeeded，在MakeUpToDate函数中对应的就是 GenerateOatFile函数。<br>也是在这面生成的oat文件<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-17.png" alt="image-17"><br>上面做了一些判断，然后调用Dex2Oat函数<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-18.png" alt="image-18"><br>Dex2Oat函数中主要是做的参数拼接，然后调用Exec函数，<br>argv[0]通过调用GetCompilerExecutable()获取获取dex2oat可执行文件的位置。</p><p><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-20.png" alt="image-20"><br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-19.png" alt="image-19"><br>可以看到，函数中创建了一个子进程调用execv函数dex2oat的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有些加固就是在这一步阻止了dex2oat，那么我们按照加固的思路继续往下看，</span><br><span class="line">回到OpenDexFilesFromOat函数MakeUpToDate函数调用之后，并未生成oat</span><br><span class="line">文件，然后调用了GetBastOatFile()函数</span><br></pre></td></tr></table></figure><p><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-21.png" alt="image-21"><br>这个函数会去查找oat文件，如果找不到，会直接返回空的指针，继续往下看<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-22.png" alt="image-22"><br>这里调用到了loadDexFiles会从oat文件中加载dex文件，因为前面并未生成oat文件，所有dex_files是空的，我们直接看第二处标记的代码，这里会直接调用Open函数对原始的dex文件进行加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前面说过加固或hook掉dex2oat的过程，然后代码就会走到这里，下面看看</span><br><span class="line">做了哪些事</span><br></pre></td></tr></table></figure><p><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-23.png" alt="image-23"><br>这里调用OpenAndReadMagic函数打开传入的文件，并获取其magic值，然后根据magic进行验证，然后进行加载，因为传入的是dex文件，会调用到OpenFile函数，加载dex文件。<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-24.png" alt="image-24"><br>首先会获取到dex的大小，在调用MapFile函数将dex加载到内存中，然后把内存重新设置给map，我们跟进去看下，<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-25.png" alt="image-25"><br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-26.png" alt="image-25"><br>在MapFileAtAddress函数中调用的mmap函数将dex文件加载到内存中，然后根据内存地址构造一个MemMap进行返回，<br>继续往下看解析dex的header，然后调用OpenMemory函数进行加载，这个函数也是早期加固中的一个脱壳点，我们继续往下看<br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-27.png" alt="image-25"><br><img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-28.png" alt="image-28"><br>可以看到OpenMemory中直接new了一个DexFile然后进行返回。到此dex文件也就加载完成了。<br>回到 DexFile_openDexFileNative函数<br> <img src="/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-29.png" alt="image-29"><br>可以看到通过ConvertNativeToJavaArray函数将dex_files转换成jlongArray，最后将其返回，也就是在java层所看到的mCookie的值，根据这个mCookie的值也可以将加载后的dex文件dump下来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前dalvik与Art上虚拟机的代码都看过，但是长时间不看就忘了，所有在此进行记录下。这里以Android6.0.1-r1的源码进行分析。&lt;br&gt;&lt;img src=&quot;/2020/12/28/Art%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8Bdex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/image-1.png&quot; alt=&quot;image-1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://marming19.github.io/categories/Android/"/>
    
    
    <category term="Android逆向" scheme="https://marming19.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
    <category term="dex加载" scheme="https://marming19.github.io/tags/dex%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>APP启动流程分析</title>
    <link href="https://marming19.github.io/2020/12/21/APP%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://marming19.github.io/2020/12/21/APP%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</id>
    <published>2020-12-21T08:44:16.000Z</published>
    <updated>2021-01-04T10:27:25.452Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们要知道，其实手机开机系统会开启一个Launcher应用程序，也就是我们所看到的手机展示页面，当我们点击页面上的应用图标的时候，app就会根据AndroidMainfest.xml文件中的配置进行启动（在配置AndroidManifest.xml文件时，将Activity的Action指定为android.intent.action.MAIN，会使Activity在一个新的Task中启动（Task是一个Activity栈）。将category指定为android.intent.category.LAUNCHER，表示通过Intent启动此Activity时，只接受category为LAUNCHER的Intent。）<br><img src="/2020/12/21/APP%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-1.png" alt="image-1"><br>下面我们看下Launcher的代码，因为app是在点击的时候启动的，所以这里直接从onClick进行分析，有兴趣的可以从onCreate开始看<br><img src="/2020/12/21/APP%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-2.png" alt="image-2"><br>这里可以看到当点击某个应用图标时，会调用到startActivitySafely()函数进行启动</p><p>其内部主要就是调用的startActivityForResult函数，继续看<br><img src="/2020/12/21/APP%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-3.png" alt="image-3"><br>这里直接调用了startActivity函数，将指向我们要启动的app的intent传递过去，继续看<br><img src="/2020/12/21/APP%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-5.png" alt="image-5"><br>首先会获取一个userHandle，这个主要是针对多用户的时候区分用户的，然后获取根据Context.LAUNCHER_APPS_SERVICE获取当前的系统服务，<br>下面就区分下，如果没有区分用户，或者是当前的用户就调用startActivity函数，否则的话就调用launcherApps.startMainActivity函数，<br>这里我们主要看startActivity，<br><img src="/2020/12/21/APP%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-4.png" alt="image-4"></p><p>这里首次调用mParent肯定是空的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先我们要知道，其实手机开机系统会开启一个Launcher应用程序，也就是我们所看到的手机展示页面，当我们点击页面上的应用图标的时候，app就会根据AndroidMainfest.xml文件中的配置进行启动（在配置AndroidManifest.xml文件时，将Activi</summary>
      
    
    
    
    <category term="Android" scheme="https://marming19.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://marming19.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>frida环境搭建与使用-1</title>
    <link href="https://marming19.github.io/2020/07/16/frida%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8-1/"/>
    <id>https://marming19.github.io/2020/07/16/frida%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8-1/</id>
    <published>2020-07-16T15:21:36.000Z</published>
    <updated>2020-12-31T06:08:45.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><p>介绍两种frida编写过程中如何智能提示，</p><p>第一种下载<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgist.github.com%2Fpcy190%2F06f522dbe7def2b3b2de44eb0dafdcaa" target="_blank" rel="noopener">frida-gum.d.ts</a>然后放到工程目录即可。<br>第二种下载如下工程，使用npm进行安装：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> https:<span class="comment">//github.com/oleavr/frida-agent-example</span></span><br><span class="line">或者</span><br><span class="line">git <span class="keyword">clone</span> https:<span class="comment">//github.com/tacesrever/frida-tsplugin</span></span><br><span class="line">cd frida-agent-example/frida-tsplugin 目录中</span><br><span class="line">执行 npm install</span><br></pre></td></tr></table></figure><p>成功后直接使用pycharm或者vscode打开工程，进行编写即可</p><a id="more"></a><h1 id="frida使用"><a href="#frida使用" class="headerlink" title="frida使用"></a>frida使用</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;开发环境搭建&quot;&gt;&lt;a href=&quot;#开发环境搭建&quot; class=&quot;headerlink&quot; title=&quot;开发环境搭建&quot;&gt;&lt;/a&gt;开发环境搭建&lt;/h1&gt;&lt;p&gt;介绍两种frida编写过程中如何智能提示，&lt;/p&gt;
&lt;p&gt;第一种下载&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fgist.github.com%2Fpcy190%2F06f522dbe7def2b3b2de44eb0dafdcaa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;frida-gum.d.ts&lt;/a&gt;然后放到工程目录即可。&lt;br&gt;第二种下载如下工程，使用npm进行安装：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt; https:&lt;span class=&quot;comment&quot;&gt;//github.com/oleavr/frida-agent-example&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt; https:&lt;span class=&quot;comment&quot;&gt;//github.com/tacesrever/frida-tsplugin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd frida-agent-example/frida-tsplugin 目录中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;执行 npm install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;成功后直接使用pycharm或者vscode打开工程，进行编写即可&lt;/p&gt;</summary>
    
    
    
    <category term="frida" scheme="https://marming19.github.io/categories/frida/"/>
    
    
    <category term="Android逆向" scheme="https://marming19.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
    <category term="frida" scheme="https://marming19.github.io/tags/frida/"/>
    
  </entry>
  
  <entry>
    <title>smali语法介绍</title>
    <link href="https://marming19.github.io/2020/06/29/smaliSyntaxIntroduction/"/>
    <id>https://marming19.github.io/2020/06/29/smaliSyntaxIntroduction/</id>
    <published>2020-06-29T15:02:47.000Z</published>
    <updated>2020-07-14T08:25:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>smali语言是Davlik虚拟机为自己专门设计的一套指令集，并且制定了自己的指令格式与调用规范。我们将Dalvik指令集组成的代码称为Dalvik汇编代码或者叫smali代码， Dalvik虚拟机是基于寄存器架构，任何的操作都要通过寄存器来完成，其寄存器有两种命名方法，分别为v命名法与p命名法。</p><h2 id="smali关键字说明"><a href="#smali关键字说明" class="headerlink" title="smali关键字说明"></a>smali关键字说明</h2><table><thead><tr><th>关键字</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>.class</td><td>.class Lcom/test/Utils;</td><td>说明当前这个smali属于哪个类</td></tr><tr><td>.super</td><td>.super Ljava/lang/Object;</td><td>说明当前这个类的父类是谁</td></tr><tr><td>.source</td><td>.source “Utils.java”</td><td>说明这个类的源文件名字<a id="more"></a></td></tr><tr><td>.implement</td><td>.implement Lcom/test/Utils;</td><td>接口实现，说明当前类实现了哪个接口</td></tr><tr><td>.method</td><td>.method public setName(Ljava/lang/String;)V</td><td>说明是函数的开始</td></tr><tr><td>.method end</td><td>xxx</td><td>说明是函数的结束位置</td></tr><tr><td>.field</td><td>.field private edt_sn:Landroid/widget/EditText;</td><td>定义字段</td></tr><tr><td>.locals</td><td>.locals 5</td><td>方法内使用的v开头的寄存器个数</td></tr><tr><td>.registers</td><td>.registers 5</td><td>表示方法内总共使用的寄存器个数(包括参数)</td></tr><tr><td>.prologue</td><td></td><td>表示方法中代码开始的位置</td></tr><tr><td>.line</td><td>.line 50</td><td>表示代码对应在Java中的行号</td></tr><tr><td>.param/.paramter</td><td>.param p0, “dexPath”</td><td>表示方法的参数</td></tr><tr><td>.annotation</td><td>.annotation build Landroid/support/annotation/Nullable;</td><td>注解的开始</td></tr><tr><td>.end annotation</td><td>xxx</td><td>注解的结束</td></tr><tr><td># direct methods</td><td></td><td>用于注释direct方法</td></tr><tr><td># virtual methods</td><td></td><td>用于注释virtual方</td></tr><tr><td>&lt; init &gt;</td><td>.method public constructor &lt; init&gt;()V</td><td>表示方法中构造函数</td></tr><tr><td>&lt; clinit&gt;</td><td>.method static constructor &lt; clinit&gt;()V</td><td>表示方法中的static代码块</td></tr></tbody></table><h2 id="方法声明-amp-调用"><a href="#方法声明-amp-调用" class="headerlink" title="方法声明&amp;调用"></a>方法声明&amp;调用</h2><p>用于调用方法，基本格式：<code>invoke-kind {vC, vD, vE, vF, vG}, meth@BBBB</code>，其中，BBBB代表方法引用（参见上面介绍的方法定义及调用），vC~G为需要的参数，根据顺序一一对应</p><p>第一部分：Lpackage/name/ObjectName；用于声明具体的类型，以便JVM寻找。</p><p>第二部分：MethodName(III)Z，其中 MethodName 为具体的方法名，()中的字符，表示了参数数量和类型，即3个int型参数，Z为返回值的类型，返回Boolean类型</p><p>如果是调用的构造函数就是把MethodName替换成<init> </init></p><p>由于方法的参数列表没有使用逗号这样的分隔符进行划分，所以只能从左到右，根据类型定义来区分参数个数。</p><p>下面举几个例子</p><table><thead><tr><th>smali</th><th>java</th></tr></thead><tbody><tr><td>Ljava/lang/String;-&gt;equals(Ljava/lang/Object)Z</td><td>“aaa”.equals(“bbb”)</td></tr><tr><td>Lab/b;-&gt;<init>()V</init></td><td>ab.b _b = new ab.b();</td></tr></tbody></table><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><style>table th:first-of-type {    width: 100px;}</style><table><thead><tr><th align="center">数据类型</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">V</td><td align="center">void ,只能用于返回值类型</td></tr><tr><td align="center">Z</td><td align="center">boolean（8 bits）</td></tr><tr><td align="center">B</td><td align="center">byte（8 bits）</td></tr><tr><td align="center">S</td><td align="center">short（16 bits）</td></tr><tr><td align="center">C</td><td align="center">char（16 bits）</td></tr><tr><td align="center">I</td><td align="center">int（32 bits）</td></tr><tr><td align="center">F</td><td align="center">float（32 bits）</td></tr><tr><td align="center">J</td><td align="center">long(64 bits)</td></tr><tr><td align="center">D</td><td align="center">double(64 bits)</td></tr><tr><td align="center">L</td><td align="center">对象的表现形式，例如String字符串的smali表现形式” Ljava/lang/String; “,注意后面的”;”一定要存在</td></tr><tr><td align="center">[</td><td align="center">数组的表现形式，例如String数组的smali表现形式” [Ljava/lang/String;”, byte数组表现形式 “[B” ，如果是多维数组只要增加”[“就可以了，例如byte[ ][ ]， smali形式为[[B</td></tr></tbody></table><h2 id="寄存器声明-amp-使用"><a href="#寄存器声明-amp-使用" class="headerlink" title="寄存器声明&amp;使用"></a>寄存器声明&amp;使用</h2><p>在Smali中，如果需要存储变量，必须先声明足够数量的寄存器，1个寄存器可以存储32位长度的类型，比如Int，而两个寄存器可以存储64位长度类型的数据，比如Long或Double。</p><p>上面表格中说过声明可使用寄存器数量的方式有两种，下面举例:</p><blockquote><p>.registers N ，   N表示函数需要使用的寄存器个数(包括参数寄存器)</p><p>.local  N ，         N表示函数中需要使用的寄存器个数(不包括参数寄存器)</p></blockquote><p><code>1.本地寄存器（local register，非参寄存器）用v开头数字结尾的符号来表示，如v0、v1、v2、…，</code></p><p><code>2.参数寄存器(parameter register)用p开头数字结尾的符号来表示，如p0、p1、p2、…，</code></p><p><code>3..registers 用来标明方法中寄存器的总数，即参数寄存器和非参寄存器的总数。</code></p><p><code>4..local 0，标明在这个函数中最少要用到的本地寄存器的个数，出现在方法中的第一行。在这里，由于只需要调用一个父类的onDestroy()处理，所以只需要用到p0，所以使用到的本地寄存器数为0，在植入代码后不要忘记可能要修改.local的值。</code></p><p><code>如 .local 4，则可以使用的寄存器是v0-v3。</code></p><p><code>5.当一个方法被调用的时候，方法的参数被置于最后N个寄存器中。</code></p><p><code>6.在实例函数中，p0代指“this”，p1表示函数的第一个参数，p2代表函数中的第二个参数…，</code></p><p><code>7.在static函数中，p0表示函数的第一个参数，p1代表函数中的第二个参数…，因为Java的static方法中没有this方法。</code></p><p><img src="/2020/06/29/smaliSyntaxIntroduction/%5CsmaliSyntaxIntroduction%5C1.png" alt="1"></p><h2 id="Dalvik指令集"><a href="#Dalvik指令集" class="headerlink" title="Dalvik指令集"></a>Dalvik指令集</h2><p>可以参考Android官方的Dalvik相关文档：<a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode#instructions" target="_blank" rel="noopener">https://source.android.com/devices/tech/dalvik/dalvik-bytecode#instructions</a></p><blockquote><p>一般的指令格式为：[op]-<a href="可选">type</a>/[位宽，默认4位] [目标寄存器],<a href="可选">源寄存器</a>，比如：move v1,v2，move-wide/from16 v1,v2</p><p>表中的vx、vy、vz表示某个Dalvik寄存器。根据不同指令可以访问16、256或64K寄存器。</p><p>表中lit4、lit8、lit16、lit32、lit64表示字面值（直接赋值），数字是值所占用位的长度。</p><p>long和double型的值占用两个寄存器，例：一个在v0寄存器的double值实际占用v0,v1两个寄存器。</p><p>boolean值的存储实际是1和0，1为真、0为假；boolean型的值实际是转成int型的值进行操作。</p><p>所有例子的字节序都采用高位存储格式，例：0F00 0A00的编译为0F, 00, 0A, 00 存储。</p></blockquote><style>table th:first-of-type {    width: 150px;}</style><table><thead><tr><th>Opcode操作码</th><th>Opcode 操作码名称</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>00</td><td>nop</td><td>无操作,空指令</td><td>0000 - nop</td></tr><tr><td>01</td><td>move vx, vy</td><td>移动vy的内容到vx。两个寄存器都必须在最初的256寄存器范围以内。</td><td>0110 - move v0, v1移动v1寄存器中的内容到v0。</td></tr><tr><td>02</td><td>move/from16 vx, vy</td><td>移动vy的内容到vx。vy可能在64K寄存器范围以内，而vx则是在最初的256寄存器范围以内。</td><td>0200 1900 - move/from16 v0, v25移动v25寄存器中的内容到v0。</td></tr><tr><td>03</td><td>move/16</td><td>将16位的v2寄存器中的值赋值到16位寄存器v1中</td><td>move/16 v1,v2</td></tr><tr><td>04</td><td>move-wide</td><td>将v2寄存器中的值赋值给v1寄存器   （支持双字型float，double）</td><td>move-wide v1,v2</td></tr><tr><td>05</td><td>move-wide/from16 vx, vy</td><td>移动一个long/double值，从vy到vx。vy可能在64K寄存器范围以内，而vx则是在最初的256寄存器范围以内。</td><td>0516 0000 - move-wide/from16 v22, v0移动v0,v1寄存器中的内容到 v22,v23。</td></tr><tr><td>06</td><td>move-wide/16</td><td>将16位的v2寄存器对中的值赋值到16位寄存器v1中</td><td>move-wide/16 v1,v2</td></tr><tr><td>07</td><td>move-object vx, vy</td><td>移动对象引用，从vy到vx。</td><td>0781 - move-object v1, v8移动v8寄存器中的对象引用到v1。</td></tr><tr><td>08</td><td>move-object/from16 vx, vy</td><td>移动对象引用，从vy到vx。vy可以处理64K寄存器地址，vx可以处理256寄存器地址。</td><td>0801 1500 - move-object/from16 v1, v21移动v21寄存器中的对象引用到v1。</td></tr><tr><td>09</td><td>move-object/16</td><td>将16位的v2寄存器中的对象指针赋值到v1寄存器中</td><td>move-object/16 v1,v2</td></tr><tr><td>0A</td><td>move-result vx</td><td>移动上一次方法调用的返回值到vx。</td><td>0A00 - move-result v0移动上一次方法调用的返回值到v0。</td></tr><tr><td>0B</td><td>move-result-wide vx</td><td>移动上一次方法调用的long/double型返回值到vx,vx+1。</td><td>0B02 - move-result-wide v2移动上一次方法调用的long/double型返回值到v2,v3。</td></tr><tr><td>0C</td><td>move-result-object vx</td><td>移动上一次方法调用的对象引用返回值到vx。</td><td>0C00 - move-result-object v0移动上一次方法调用的对象引用返回值到v0。</td></tr><tr><td>0D</td><td>move-exception vx</td><td>当方法调用抛出异常时移动异常对象引用到vx。</td><td>0D19 - move-exception v25当方法调用抛出异常时移动异常对象引用到v25。</td></tr><tr><td>0E</td><td>return-void</td><td>返回空值。</td><td>0E00 - return-void返回值为void，即无返回值，并非返回null。</td></tr><tr><td>0F</td><td>return vx</td><td>返回在vx寄存器的值。</td><td>0F00 - return v0返回v0寄存器中的值。</td></tr><tr><td>10</td><td>return-wide vx</td><td>返回在vx,vx+1寄存器的double/long值。</td><td>1000 - return-wide v0返回v0,v1寄存器中的double/long值。</td></tr><tr><td>11</td><td>return-object vx</td><td>返回在vx寄存器的对象引用。</td><td>1100 - return-object v0返回v0寄存器中的对象引用。</td></tr><tr><td>12</td><td>const/4 vx, lit4</td><td>存入4位常量到vx。</td><td>1221 - const/4 v1, #int 2存入int型常量2到v1。目的寄存器在第二个字节的低4位，常量2在更高的4位。</td></tr><tr><td>13</td><td>const/16 vx, lit16</td><td>存入16位常量到vx。</td><td>1300 0A00 - const/16 v0, #int 10存入int型常量10到v0。</td></tr><tr><td>14</td><td>const vx, lit32</td><td>存入int 型常量到vx。</td><td>1400 4E61 BC00 - const v0, #12345678 // #00BC614E存入常量12345678到v0。</td></tr><tr><td>15</td><td>const/high16 v0, lit16</td><td>存入16位常量到最高位寄存器，用于初始化float值。</td><td>1500 2041 - const/high16 v0, #float 10.0 // #41200000存入float常量10.0到v0。该指令最高支持16位浮点数。</td></tr><tr><td>16</td><td>const-wide/16 vx, lit16</td><td>存入int常量到vx,vx+1寄存器，扩展int型常量为long常量。</td><td>1600 0A00 - const-wide/16 v0, #long 10存入long常量10到v0,v1寄存器。</td></tr><tr><td>17</td><td>const-wide/32 vx, lit32</td><td>存入32位常量到vx,vx+1寄存器，扩展int型常量到long常量。</td><td>1702 4e61 bc00 - const-wide/32 v2, #long 12345678 // #00bc614e存入long常量12345678到v2,v3寄存器。</td></tr><tr><td>18</td><td>const-wide vx, lit64</td><td>存入64位常量到vx,vx+1寄存器。</td><td>1802 874b 6b5d 54dc 2b00- const-wide v2, #long 12345678901234567 // #002bdc545d6b4b87存入long常量12345678901234567到v2,v3寄存器。</td></tr><tr><td>19</td><td>const-wide/high16 vx, lit16</td><td>存入16位常量到最高16位的vx,vx+1寄存器，用于初始化double 值。</td><td>1900 2440 - const-wide/high16 v0, #double 10.0 // #402400000存入double常量10.0到v0,v1。</td></tr><tr><td>1A</td><td>const-string vx, <em>字符串**ID</em></td><td>存入字符串常量引用到vx，通过<em>字符串*</em>ID<em>或</em>字符串*。</td><td>1A08 0000 - const-string v8, “” // string@0000存入string@0000（字符串表#0条目）的引用到v8。</td></tr><tr><td>1B</td><td>const-string-jumbo</td><td>存入字符串常量引用到vx，通过<em>字符串*<em>ID</em>或*字符串</em></td><td>const-string-jumbo v8, “” // string@0000存入string@0000（字符串表#0条目）的引用到v8。</td></tr><tr><td>1C</td><td>const-class vx, <em>类型**ID</em></td><td>存入类对象常量到vx，通过<em>类型*</em>ID<em>或</em>类型*（如Object.class）。</td><td>1C00 0100 - const-class v0, Test3 // type@0001存入Test3.class（类型ID表#1条目）的引用到v0。</td></tr><tr><td>1D</td><td>monitor-enter vx</td><td>获得vx寄存器中的对象引用的监视器。</td><td>1D03 - monitor-enter v3获得v3寄存器中的对象引用的监视器。</td></tr><tr><td>1E</td><td>monitor-exit</td><td>释放vx寄存器中的对象引用的监视器。</td><td>1E03 - monitor-exit v3释放v3寄存器中的对象引用的监视器。</td></tr><tr><td>1F</td><td>check-cast vx, <em>类型**ID</em></td><td>检查vx寄存器中的对象引用是否可以转换成<em>类型*</em>ID*对应类型的实例。如不可转换，抛出ClassCastException 异常，否则继续执行。</td><td>1F04 0100 - check-cast v4, Test3 // type@0001检查v4寄存器中的对象引用是否可以转换成Test3（类型ID表#1条目）的实例。</td></tr><tr><td>20</td><td>instance-of vx, vy,<em>类型**ID</em></td><td>检查vy寄存器中的对象引用是否是<em>类型*</em>ID*对应类型的实例，如果是，vx存入非0值，否则vx存入0。</td><td>2040 0100 - instance-of v0, v4, Test3 // type@0001检查v4寄存器中的对象引用是否是Test3（类型ID表#1条目）的实例。如果是，v0存入非0值，否则v0存入0。</td></tr><tr><td>21</td><td>array-length vx, vy</td><td>计算vy寄存器中数组引用的元素长度并将长度存入vx。</td><td>2111 - array-length v0, v1计算v1寄存器中数组引用的元素长度并将长度存入v0。</td></tr><tr><td>22</td><td>new-instance vx, <em>类型**ID</em></td><td>根据<em>类型*</em>ID<em>或</em>类型*新建一个对象实例，并将新建的对象的引用存入vx。</td><td>2200 1500 - new-instance v0, java.io.FileInputStream // type@0015实例化java.io.FileInputStream（类型ID表#15H条目）类型，并将其对象引用存入v0。</td></tr><tr><td>23</td><td>new-array vx, vy,<em>类型**ID</em></td><td>根据<em>类型*</em>ID<em>或</em>类型*新建一个数组，vy存入数组的长度，vx存入数组的引用。</td><td>2312 2500 - new-array v2, v1, char[] // type@0025新建一个char（类型ID表#25H条目）数组，v1存入数组的长度，v2存入数组的引用。</td></tr><tr><td>24</td><td>filled-new-array {<em>参数</em>}, <em>类型**ID</em></td><td>根据<em>类型*</em>ID<em>或</em>类型<em>新建一个数组并通过</em>参数*填充注5。新的数组引用可以得到一个move-result-object指令，前提是执行过filled-new-array 指令。</td><td>2420 530D 0000 - filled-new-array {v0,v0},[I // type@0D53新建一个int（类型ID表#D53H条目）数组，长度将为2并且2个元素将填充到v0寄存器。</td></tr><tr><td>25</td><td>filled-new-array-range {vx..vy}, <em>类型**ID</em></td><td>根据<em>类型*</em>ID<em>或</em>类型*新建一个数组并以寄存器范围为参数填充。新的数组引用可以得到一个move-result-object指令，前提是执行过filled-new-array 指令。</td><td>2503 0600 1300 - filled-new-array/range {v19..v21}, [B // type@0006新建一个byte（类型ID表#6条目）数组，长度将为3并且3个元素将填充到v19,v20,v21寄存器注4。</td></tr><tr><td>26</td><td>fill-array-data vx, <em>偏移量</em></td><td>用vx的静态数据填充数组引用。静态数据的位址是当前指令位置加<em>偏移量</em>的和。</td><td>2606 2500 0000 - fill-array-data v6, 00e6 // +0025用当前指令位置+25H的静态数据填充v6寄存器的数组引用。偏移量是32位的数字，静态数据的存储格式如下：0003 // 表类型：静态数组数据0400 // 每个元素的字节数（这个例子是4字节的int型）0300 0000 // 元素个数0100 0000 // 元素 #0：int 10200 0000 // 元素 #1：int 20300 0000 // 元素 #2：int 3</td></tr><tr><td>27</td><td>throw vx</td><td>抛出异常对象，异常对象的引用在vx寄存器。</td><td>2700 - throw v0抛出异常对象，异常对象的引用在v0寄存器。</td></tr><tr><td>28</td><td>goto <em>目标</em></td><td>通过短偏移量注2无条件跳转到<em>目标</em>。</td><td>28F0 - goto 0005 // -0010跳转到当前位置-16（hex 10）的位置，0005是目标指令标签。</td></tr><tr><td>29</td><td>goto/16<em>目标</em></td><td>通过16位偏移量注2无条件跳转到<em>目标</em>。</td><td>2900 0FFE - goto/16 002f // -01f1跳转到当前位置-1F1H的位置，002f是目标指令标签。</td></tr><tr><td>2A</td><td>goto/32<em>目标</em></td><td>通过32位偏移量注2无条件跳转到<em>目标</em>。</td><td></td></tr><tr><td>2B</td><td>packed-switch vx, <em>索引表偏移量</em></td><td>实现一个switch 语句，case常量是连续的。这个指令使用<em>索引表</em>，vx是在表中找到具体case的指令偏移量的索引，如果无法在表中找到vx对应的索引将继续执行下一个指令（即default case）。</td><td>2B02 0C00 0000 - packed-switch v2, 000c // +000c根据v2寄存器中的值执行packed switch，索引表的位置是当前指令位置+0CH，表如下所示：0001 // 表类型：packed switch表0300 // 元素个数0000 0000 // 基础元素0500 0000 0: 00000005 // case 0: +000000050700 0000 1: 00000007 // case 1: +000000070900 0000 2: 00000009 // case 2: +00000009</td></tr><tr><td>2C</td><td>sparse-switch vx, <em>查询表偏移量</em></td><td>实现一个switch 语句，case常量是非连续的。这个指令使用<em>查询表</em>，用于表示case常量和每个case常量的偏移量。如果vx无法在表中匹配将继续执行下一个指令（即default case）。</td><td>2C02 0c00 0000 - sparse-switch v2, 000c // +000c根据v2寄存器中的值执行sparse switch ，查询表的位置是当前指令位置+0CH，表如下所示：0002 // 表类型：sparse switch表0300 // 元素个数9cff ffff // 第一个case常量: -100fa00 0000 // 第二个case常量: 250e803 0000 // 第三个case常量: 10000500 0000 // 第一个case常量的偏移量: +50700 0000 // 第二个case常量的偏移量: +70900 0000 // 第三个case常量的偏移量: +9</td></tr><tr><td>2D</td><td>cmpl-float vx, vy, vz</td><td>比较vy和vz的float值并在vx存入int型返回值注3。</td><td>2D00 0607 - cmpl-float v0, v6, v7比较v6和v7的float值并在v0存入int型返回值。非数值默认为小于。如果参数为非数值将返回-1。</td></tr><tr><td>2E</td><td>cmpg-float vx, vy, vz</td><td>比较vy和vz的float值并在vx存入int型返回值注3。</td><td>2E00 0607 - cmpg-float v0, v6, v7比较v6和v7的float值并在v0存入int型返回值。非数值默认为大于。如果参数为非数值将返回1。</td></tr><tr><td>2F</td><td>cmpl-double vx, vy, vz</td><td>比较vy和vz注2的double值并在vx存入int型返回值注3。</td><td>2F19 0608 - cmpl-double v25, v6, v8比较v6,v7和v8,v9的double值并在v25存入int型返回值。非数值默认为小于。如果参数为非数值将返回-1。</td></tr><tr><td>30</td><td>cmpg-double vx, vy, vz</td><td>比较vy和vz注2的double值并在vx存入int型返回值注3。</td><td>3000 080A - cmpg-double v0, v8, v10比较v8,v9和v10,v11的double值并在v0存入int型返回值。非数值默认为大于。如果参数为非数值将返回1。</td></tr><tr><td>31</td><td>cmp-long vx, vy, vz</td><td>比较vy和vz的long值并在vx存入int型返回值注3。</td><td>3100 0204 - cmp-long v0, v2, v4比较v2和v4的long值并在v0存入int型返回值。</td></tr><tr><td>32</td><td>if-eq vx,vy, <em>目标</em></td><td>如果vx == vy注2，跳转到<em>目标</em>。vx和vy是int型值。</td><td>32b3 6600 - if-eq v3, v11, 0080 // +0066如果v3 == v11，跳转到当前位置+66H。0080是目标指令标签。</td></tr><tr><td>33</td><td>if-ne vx,vy, <em>目标</em></td><td>如果vx != vy注2，跳转到<em>目标</em>。vx和vy是int型值。</td><td>33A3 1000 - if-ne v3, v10, 002c // +0010如果v3 != v10，跳转到当前位置+10H。002c是目标指令标签。</td></tr><tr><td>34</td><td>if-lt vx,vy, <em>目标</em></td><td>如果vx &lt; vy注2，跳转到<em>目标</em>。vx和vy是int型值。</td><td>3432 CBFF - if-lt v2, v3, 0023 // -0035如果v2 &lt; v3，跳转到当前位置-35H。0023是目标指令标签。</td></tr><tr><td>35</td><td>if-ge vx, vy, <em>目标</em></td><td>如果vx &gt;= vy注2，跳转到<em>目标</em>。vx和vy是int型值。</td><td>3510 1B00 - if-ge v0, v1, 002b // +001b如果v0 &gt;= v1，跳转到当前位置+1BH。002b是目标指令标签。</td></tr><tr><td>36</td><td>if-gt vx,vy, <em>目标</em></td><td>如果vx &gt; vy注2，跳转到<em>目标</em>。vx和vy是int型值。</td><td>3610 1B00 - if-ge v0, v1, 002b // +001b如果v0 &gt; v1，跳转到当前位置+1BH。002b是目标指令标签。</td></tr><tr><td>37</td><td>if-le vx,vy, <em>目标</em></td><td>如果vx &lt;= vy注2，跳转到<em>目标</em>。vx和vy是int型值。</td><td>3756 0B00 - if-le v6, v5, 0144 // +000b如果v6 &lt;= v5，跳转到当前位置+0BH。0144是目标指令标签。</td></tr><tr><td>38</td><td>if-eqz vx, <em>目标</em></td><td>如果vx == 0注2，跳转到<em>目标</em>。vx是int型值。</td><td>3802 1900 - if-eqz v2, 0038 // +0019如果v2 == 0，跳转到当前位置+19H。0038是目标指令标签。</td></tr><tr><td>39</td><td>if-nez vx, <em>目标</em></td><td>如果vx != 0注2，跳转到<em>目标</em>。</td><td>3902 1200 - if-nez v2, 0014 // +0012如果v2 != 0，跳转到当前位置+18(hex 12)。0014是目标指令标签。</td></tr><tr><td>3A</td><td>if-ltz vx, <em>目标</em></td><td>如果vx &lt; 0注2，跳转到<em>目标</em>。</td><td>3A00 1600 - if-ltz v0, 002d // +0016如果v0 &lt; 0，跳转到当前位置+16H。002d是目标指令标签。</td></tr><tr><td>3B</td><td>if-gez vx, <em>目标</em></td><td>如果vx &gt;= 0注2，跳转到<em>目标</em>。</td><td>3B00 1600 - if-gez v0, 002d // +0016如果v0 &gt;= 0，跳转到当前位置+16H。002d是目标指令标签。</td></tr><tr><td>3C</td><td>if-gtz vx, <em>目标</em></td><td>如果vx &gt; 0注2，跳转到<em>目标</em>。</td><td>3C00 1D00 - if-gtz v0, 004a // +001d如果v0 &gt; 0，跳转到当前位置+1DH。004a是目标指令标签。</td></tr><tr><td>3D</td><td>if-lez vx, <em>目标</em></td><td>如果vx &lt;= 0注2，跳转到<em>目标</em>。</td><td>3D00 1D00 - if-lez v0, 004a // +001d如果v0 &lt;= 0，跳转到当前位置+1DH。004a是目标指令标签。</td></tr><tr><td>3E</td><td>unused_3E</td><td>未使用</td><td></td></tr><tr><td>3F</td><td>unused_3F</td><td>未使用</td><td></td></tr><tr><td>40</td><td>unused_40</td><td>未使用</td><td></td></tr><tr><td>41</td><td>unused_41</td><td>未使用</td><td></td></tr><tr><td>42</td><td>unused_42</td><td>未使用</td><td></td></tr><tr><td>43</td><td>unused_43</td><td>未使用</td><td></td></tr><tr><td>44</td><td>aget vx, vy, vz</td><td>从int数组获取一个int型值到vx，对象数组的引用位于vy，需获取的元素的索引位于vz。</td><td>4407 0306 - aget v7, v3, v6从数组获取一个int型值到v7，对象数组的引用位于v3，需获取的元素的索引位于v6。</td></tr><tr><td>45</td><td>aget-wide vx, vy, vz</td><td>从long/double数组获取一个long/double值到vx,vx+1，数组的引用位于vy，需获取的元素的索引位于vz。</td><td>4505 0104 - aget-wide v5, v1, v4从long/double数组获取一个long/double值到v5,vx6，数组的引用位于v1，需获取的元素的索引位于v4。</td></tr><tr><td>46</td><td>aget-object vx, vy, vz</td><td>从对象引用数组获取一个对象引用到vx，对象数组的引用位于vy，需获取的元素的索引位于vz。</td><td>4602 0200 - aget-object v2, v2, v0从对象引用数组获取一个对象引用到v2，对象数组的引用位于v2，需获取的元素的索引位于v0。</td></tr><tr><td>47</td><td>aget-boolean vx, vy, vz</td><td>从boolean数组获取一个boolean值到vx，数组的引用位于vy，需获取的元素的索引位于vz。</td><td>4700 0001 - aget-boolean v0, v0, v1从boolean数组获取一个boolean值到v0，数组的引用位于v0，需获取的元素的索引位于v1。</td></tr><tr><td>48</td><td>aget-byte vx, vy, vz</td><td>从byte数组获取一个byte值到vx，数组的引用位于vy，需获取的元素的索引位于vz。</td><td>4800 0001 - aget-byte v0, v0, v1从byte数组获取一个byte值到v0，数组的引用位于v0，需获取的元素的索引位于v1。</td></tr><tr><td>49</td><td>aget-char vx, vy, vz</td><td>从char数组获取一个char值到vx，数组的引用位于vy，需获取的元素的索引位于vz。</td><td>4905 0003 - aget-char v5, v0, v3从char数组获取一个char值到v5，数组的引用位于v0，需获取的元素的索引位于v3。</td></tr><tr><td>4A</td><td>aget-short vx, vy, vz</td><td>从short数组获取一个short值到vx，数组的引用位于vy，需获取的元素的索引位于vz。</td><td>4A00 0001 - aget-short v0, v0, v1从short数组获取一个short值到v0，数组的引用位于v0，需获取的元素的索引位于v1。</td></tr><tr><td>4B</td><td>aput vx, vy, vz</td><td>将vx的int值作为元素存入int数组，数组的引用位于vy，元素的索引位于vz。</td><td>4B00 0305 - aput v0, v3, v5将v0的int值作为元素存入int数组，数组的引用位于v3，元素的索引位于v5。</td></tr><tr><td>4C</td><td>aput-wide vx, vy, vz</td><td>将vx,vx+1的double/long值作为元素存入double/long数组，数组的引用位于vy，元素的索引位于vz。</td><td>4C05 0104 - aput-wide v5, v1, v4将v5,v6的double/long值作为元素存入double/long数组，数组的引用位于v1，元素的索引位于v4。</td></tr><tr><td>4D</td><td>aput-object vx, vy, vz</td><td>将vx的对象引用作为元素存入对象引用数组，数组的引用位于vy，元素的索引位于vz。</td><td>4D02 0100 - aput-object v2, v1, v0将v2的对象引用作为元素存入对象引用数组，数组的引用位于v1，元素的索引位于v0。</td></tr><tr><td>4E</td><td>aput-boolean vx, vy, vz</td><td>将vx的boolean值作为元素存入boolean数组，数组的引用位于vy，元素的索引位于vz。</td><td>4E01 0002 - aput-boolean v1, v0, v2将v1的boolean值作为元素存入boolean数组，数组的引用位于v0，元素的索引位于v2。</td></tr><tr><td>4F</td><td>aput-byte vx, vy, vz</td><td>将vx的byte值作为元素存入byte数组，数组的引用位于vy，元素的索引位于vz。</td><td>4F02 0001 - aput-byte v2, v0, v1将v2的byte值作为元素存入byte数组，数组的引用位于v0，元素的索引位于v1。</td></tr><tr><td>50</td><td>aput-char vx, vy, vz</td><td>将vx的char值作为元素存入char数组，数组的引用位于vy，元素的索引位于vz。</td><td>5003 0001 - aput-char v3, v0, v1将v3的char值作为元素存入char数组，数组的引用位于v0，元素的索引位于v1。</td></tr><tr><td>51</td><td>aput-short vx, vy, vz</td><td>将vx的short值作为元素存入short数组，数组的引用位于vy，元素的索引位于vz。</td><td>5102 0001 - aput-short v2, v0, v1将v2的short值作为元素存入short数组，数组的引用位于v0，元素的索引位于v1。</td></tr><tr><td>52</td><td>iget vx, vy, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*读取实例的int型字段到vx，vy寄存器中是该实例的引用。</td><td>5210 0300 - iget v0, v1, Test2.i6:I // field@0003读取int型字段i6（字段表#3条目）到v0，v1寄存器中是Test2实例的引用。</td></tr><tr><td>53</td><td>iget-wide vx, vy, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*读取实例的double/long型字段到vx,vx+1注1，vy寄存器中是该实例的引用。</td><td>5320 0400 - iget-wide v0, v2, Test2.l0:J // field@0004读取long型字段l0（字段表#4条目）到v0,v1，v2寄存器中是Test2实例的引用。</td></tr><tr><td>54</td><td>iget-object vx, vy, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*读取一个实例的对象引用字段到vx，vy寄存器中是该实例的引用。</td><td>iget-object v1, v2, LineReader.fis:Ljava/io/FileInputStream; // field@0002读取FileInputStream对象引用字段fis（字段表#2条目）到v1，v2寄存器中是LineReader实例的引用。</td></tr><tr><td>55</td><td>iget-boolean vx, vy, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*读取实例的boolean型字段到vx，vy寄存器中是该实例的引用。</td><td>55FC 0000 - iget-boolean v12, v15, Test2.b0:Z // field@0000读取boolean型字段b0（字段表#0条目）到v12，v15寄存器中是Test2实例的引用。</td></tr><tr><td>56</td><td>iget-byte vx, vy, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*读取实例的byte型字段到vx，vy寄存器中是该实例的引用。</td><td>5632 0100 - iget-byte v2, v3, Test3.bi1:B // field@0001读取byte型字段bi1（字段表#1条目）到v2，v3寄存器中是Test2实例的引用。</td></tr><tr><td>57</td><td>iget-char vx, vy, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*读取实例的char型字段到vx，vy寄存器中是该实例的引用。</td><td>5720 0300 - iget-char v0, v2, Test3.ci1:C // field@0003读取char型字段bi1（字段表#3条目）到v0，v2寄存器中是Test2实例的引用。</td></tr><tr><td>58</td><td>iget-short vx, vy, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*读取实例的short型字段到vx，vy寄存器中是该实例的引用。</td><td>5830 0800 - iget-short v0, v3, Test3.si1:S // field@0008读取short型字段si1（字段表#8条目）到v0，v3寄存器中是Test2实例的引用。</td></tr><tr><td>59</td><td>iput vx, vy, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*将vx寄存器的值存入实例的int型字段，vy寄存器中是该实例的引用。</td><td>5920 0200 - iput v0, v2, Test2.i6:I // field@0002将v0寄存器的值存入实例的int型字段i6（字段表#2条目），v2寄存器中是Test2实例的引用。</td></tr><tr><td>5A</td><td>iput-wide vx, vy, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*将vx,vx+1寄存器的值存入实例的double/long型字段，vy寄存器中是该实例的引用。</td><td>5A20 0000 - iput-wide v0, v2, Test2.d0:D // field@0000将v0,v1寄存器的值存入实例的double型字段d0（字段表#0条目），v2寄存器中是Test2实例的引用。</td></tr><tr><td>5B</td><td>iput-object vx, vy, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*将vx寄存器的值存入实例的对象引用字段，vy寄存器中是该实例的引用。</td><td>5B20 0000 - iput-object v0, v2, LineReader.bis:Ljava/io/BufferedInputStream; // field@0000将v0寄存器的值存入实例的对象引用字段bis（字段表#0条目），v2寄存器中是BufferedInputStream实例的引用。</td></tr><tr><td>5C</td><td>iput-boolean vx, vy, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*将vx寄存器的值存入实例的boolean型字段，vy寄存器中是该实例的引用。</td><td>5C30 0000 - iput-boolean v0, v3, Test2.b0:Z // field@0000将v0寄存器的值存入实例的boolean型字段b0（字段表#0条目），v3寄存器中是Test2实例的引用。</td></tr><tr><td>5D</td><td>iput-byte vx, vy, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*将vx寄存器的值存入实例的byte型字段，vy寄存器中是该实例的引用。</td><td>5D20 0100 - iput-byte v0, v2, Test3.bi1:B // field@0001将v0寄存器的值存入实例的byte型字段bi1（字段表#1条目），v2寄存器中是Test2实例的引用。</td></tr><tr><td>5E</td><td>iput-char vx, vy, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*将vx寄存器的值存入实例的char型字段，vy寄存器中是该实例的引用。</td><td>5E20 0300 - iput-char v0, v2, Test3.ci1:C // field@0003将v0寄存器的值存入实例的char型字段ci1（字段表#3条目），v2寄存器中是Test2实例的引用。</td></tr><tr><td>5F</td><td>iput-short vx, vy, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*将vx寄存器的值存入实例的short型字段，vy寄存器中是该实例的引用。</td><td>5F21 0800 - iput-short v1, v2, Test3.si1:S // field@0008将v0寄存器的值存入实例的short型字段si1（字段表#8条目），v2寄存器中是Test2实例的引用。</td></tr><tr><td>60</td><td>sget vx, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*读取静态int型字段到vx。</td><td>6000 0700 - sget v0, Test3.is1:I // field@0007读取Test3的静态int型字段is1（字段表#7条目）到v0。</td></tr><tr><td>61</td><td>sget-wide vx, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*读取静态double/long型字段到vx,vx+1。</td><td>6100 0500 - sget-wide v0, Test2.l1:J // field@0005读取Test2的静态long型字段l1（字段表#5条目）到v0,v1。</td></tr><tr><td>62</td><td>sget-object vx, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*读取静态对象引用字段到vx。</td><td>6201 0C00 - sget-object v1, Test3.os1:Ljava/lang/Object; // field@000c读取Object的静态对象引用字段os1（字段表#CH条目）到v1。</td></tr><tr><td>63</td><td>sget-boolean vx, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*读取静态boolean型字段到vx。</td><td>6300 0C00 - sget-boolean v0, Test2.sb:Z // field@000c读取Test2的静态boolean型字段sb（字段表#CH条目）到v0。</td></tr><tr><td>64</td><td>sget-byte vx, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*读取静态byte型字段到vx。</td><td>6400 0200 - sget-byte v0, Test3.bs1:B // field@0002读取Test3的静态byte型字段bs1（字段表#2条目）到v0。</td></tr><tr><td>65</td><td>sget-char vx, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*读取静态char型字段到vx。</td><td>6500 0700 - sget-char v0, Test3.cs1:C // field@0007读取Test3的静态char型字段cs1（字段表#7条目）到v0。</td></tr><tr><td>66</td><td>sget-short vx, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*读取静态short型字段到vx。</td><td>6600 0B00 - sget-short v0, Test3.ss1:S // field@000b读取Test3的静态short型字段ss1（字段表#CH条目）到v0。</td></tr><tr><td>67</td><td>sput vx, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*将vx寄存器中的值赋值到int型静态字段。</td><td>6700 0100 - sput v0, Test2.i5:I // field@0001将v0寄存器中的值赋值到Test2的int型静态字段i5（字段表#1条目）。</td></tr><tr><td>68</td><td>sput-wide vx, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*将vx,vx+1寄存器中的值赋值到double/long型静态字段。</td><td>6800 0500 - sput-wide v0, Test2.l1:J // field@0005将v0,v1寄存器中的值赋值到Test2的long型静态字段l1（字段表#5条目）。</td></tr><tr><td>69</td><td>sput-object vx, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*将vx寄存器中的对象引用赋值到对象引用静态字段。</td><td>6900 0c00 - sput-object v0, Test3.os1:Ljava/lang/Object; // field@000c将v0寄存器中的对象引用赋值到Test3的对象引用静态字段os1（字段表#CH条目）。</td></tr><tr><td>6A</td><td>sput-boolean vx, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*将vx寄存器中的值赋值到boolean型静态字段。</td><td>6A00 0300 - sput-boolean v0, Test3.bls1:Z // field@0003将v0寄存器中的值赋值到Test3的boolean型静态字段bls1（字段表#3条目）。</td></tr><tr><td>6B</td><td>sput-byte vx, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*将vx寄存器中的值赋值到byte型静态字段。</td><td>6B00 0200 - sput-byte v0, Test3.bs1:B // field@0002将v0寄存器中的值赋值到Test3的byte型静态字段bs1（字段表#2条目）。</td></tr><tr><td>6C</td><td>sput-char vx, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*将vx寄存器中的值赋值到char型静态字段。</td><td>6C01 0700 - sput-char v1, Test3.cs1:C // field@0007将v1寄存器中的值赋值到Test3的char型静态字段cs1（字段表#7条目）。</td></tr><tr><td>6D</td><td>sput-short vx, <em>字段**ID</em></td><td>根据<em>字段*</em>ID*将vx寄存器中的值赋值到short型静态字段。</td><td>6D00 0B00 - sput-short v0, Test3.ss1:S // field@000b将v0寄存器中的值赋值到Test3的short型静态字段ss1（字段表#BH条目）。</td></tr><tr><td>6E</td><td>invoke-virtual {<em>参数</em>}, <em>方法名</em></td><td>调用带<em>参数</em>的虚拟方法。</td><td>6E53 0600 0421 - invoke-virtual { v4, v0, v1, v2, v3}, Test2.method5:(IIII)V // method@0006调用Test2的method5（方法表#6条目）方法，该指令共有5个参数（操作码第二个字节的4个最高有效位5）注5。参数v4是”this”实例，v0, v1, v2, v3是method5方法的参数，(IIII)V的4个I分表表示4个int型参数，V表示返回值为void。</td></tr><tr><td>6F</td><td>invoke-super {<em>参数</em>}, <em>方法名</em></td><td>调用带<em>参数</em>的直接父类的虚拟方法。</td><td>6F10 A601 0100 invoke-super {v1},java.io.FilterOutputStream.close:()V // method@01a6调用java.io.FilterOutputStream的close（方法表#1A6条目）方法，参数v1是”this”实例。()V表示close方法没有参数，V表示返回值为void。</td></tr><tr><td>70</td><td>invoke-direct {<em>参数</em>}, <em>方法名</em></td><td>不解析直接调用带<em>参数</em>的方法。</td><td>7010 0800 0100 - invoke-direct {v1}, java.lang.Object.<init>:()V // method@0008调用java.lang.Object 的<init>（方法表#8条目）方法，参数v1是”this”实例注5。()V表示<init>方法没有参数，V表示返回值为void。</init></init></init></td></tr><tr><td>71</td><td>invoke-static {<em>参数</em>}, <em>方法名</em></td><td>调用带<em>参数</em>的静态方法。</td><td>7110 3400 0400 - invoke-static {v4}, java.lang.Integer.parseInt:( Ljava/lang/String;)I // method@0034调用java.lang.Integer 的parseInt（方法表#34条目）静态方法，该指令只有1个参数v4注5，(Ljava/lang/String;)I中的Ljava/lang/String;表示parseInt方法需要String类型的参数，I表示返回值为int型。</td></tr><tr><td>72</td><td>invoke-interface {<em>参数</em>}, <em>方法名</em></td><td>调用带<em>参数</em>的接口方法。</td><td>7240 2102 3154 invoke-interface {v1, v3, v4, v5}, mwfw.IReceivingProtocolAdapter.receivePackage:(ILjava/lang/String;Ljava/io/InputStream;)Z // method@0221调用mwfw.IReceivingProtocolAdapter 接口的receivePackage方法（方法表#221条目），该指令共有4个参数注5，参数v1是”this”实例，v3,v4,v5是receivePackage方法的参数，(ILjava/lang/String;Ljava/io/InputStream;)Z中的I表示int型参数，Ljava/lang/String;表示String类型参数，Ljava/io/InputStream;表示InputStream类型参数，Z表示返回值为boolean型。</td></tr><tr><td>73</td><td>unused_73</td><td>未使用</td><td></td></tr><tr><td>74</td><td>invoke-virtual/range {vx..vy}, <em>方法名</em></td><td>调用以寄存器范围为参数的虚拟方法。该指令第一个寄存器和寄存器的数量将传递给方法。</td><td>7403 0600 1300 - invoke-virtual {v19..v21}, Test2.method5:(IIII)V // method@0006调用Test2的method5（方法表#6条目）方法，该指令共有3个参数。参数v19是”this”实例，v20,v21是method5方法的参数，(IIII)V的4个I分表表示4个int型参数，V表示返回值为void。</td></tr><tr><td>75</td><td>invoke-super/range {vx..vy}, <em>方法名</em></td><td>调用以寄存器范围为参数的直接父类的虚拟方法。该指令第一个寄存器和寄存器的数量将会传递给方法。</td><td>7501 A601 0100 invoke-super {v1},java.io.FilterOutputStream.close:()V // method@01a6调用java.io.FilterOutputStream的close（方法表#1A6条目）方法，参数v1是”this”实例。()V表示close方法没有参数，V表示返回值为void。</td></tr><tr><td>76</td><td>invoke-direct/range {vx..vy}, <em>方法名</em></td><td>不解析直接调用以寄存器范围为参数的方法。该指令第一个寄存器和寄存器的数量将会传递给方法。</td><td>7603 3A00 1300 - invoke-direct/range {v19..21},java.lang.Object.<init>:()V // method@003a调用java.lang.Object 的<init>（方法表#3A条目）方法，参数v19是”this”实例（操作码第五、第六字节表示范围从v19开始，第二个字节为03表示传入了3个参数），()V表示<init>方法没有参数，V表示返回值为void。</init></init></init></td></tr><tr><td>77</td><td>invoke-static/range {vx..vy}, <em>方法名</em></td><td>调用以寄存器范围为参数的静态方法。该指令第一个寄存器和寄存器的数量将会传递给方法。</td><td>7703 3A00 1300 - invoke-static/range {v19..21},java.lang.Integer.parseInt:(Ljava/lang/String;)I // method@0034调用java.lang.Integer 的parseInt（方法表#34条目）静态方法，参数v19是”this”实例（操作码第五、第六字节表示范围从v19开始，第二个字节为03表示传入了3个参数），(Ljava/lang/String;)I中的Ljava/lang/String;表示parseInt方法需要String类型的参数，I表示返回值为int型。</td></tr><tr><td>78</td><td>invoke-interface-range {vx..vy}, <em>方法名</em></td><td>调用以寄存器范围为参数的接口方法。该指令第一个寄存器和寄存器的数量将会传递给方法。</td><td>7840 2102 0100 invoke-interface {v1..v4}, mwfw.IReceivingProtocolAdapter.receivePackage:(ILjava/lang/String;Ljava/io/InputStream;)Z // method@0221调用mwfw.IReceivingProtocolAdapter 接口的receivePackage方法（方法表#221条目），该指令共有4个参数注5，参数v1是”this”实例，v2,v3,v4是receivePackage方法的参数，(ILjava/lang/String;Ljava/io/InputStream;)Z中的I表示int型参数，Ljava/lang/String;表示String类型参数，Ljava/io/InputStream;表示InputStream类型参数，Z表示返回值为boolean型。</td></tr><tr><td>79</td><td>unused_79</td><td>未使用</td><td></td></tr><tr><td>7A</td><td>unused_7A</td><td>未使用</td><td></td></tr><tr><td>7B</td><td>neg-int vx, vy</td><td>计算vx = -vy并将结果存入vx。</td><td>7B01 - neg-int v1,v0计算-v0并将结果存入v1。</td></tr><tr><td>7C</td><td>not-int vx, vy</td><td>未知注4</td><td></td></tr><tr><td>7D</td><td>neg-long vx, vy</td><td>计算vx,vx+1 = -(vy,vy+1) 并将结果存入vx,vx+1。</td><td>7D02 - neg-long v2,v0计算-(v0,v1) 并将结果存入(v2,v3)。</td></tr><tr><td>7E</td><td>not-long vx, vy</td><td>未知注4</td><td></td></tr><tr><td>7F</td><td>neg-float vx, vy</td><td>计算vx = -vy并将结果存入vx。</td><td>7F01 - neg-float v1,v0计算-v0并将结果存入v1。</td></tr><tr><td>80</td><td>neg-double vx, vy</td><td>计算vx,vx+1=-(vy,vy+1) 并将结果存入vx,vx+1。</td><td>8002 - neg-double v2,v0计算-(v0,v1) 并将结果存入(v2,v3)。</td></tr><tr><td>81</td><td>int-to-long vx, vy</td><td>转换vy寄存器中的int型值为long型值存入vx,vx+1。</td><td>8106 - int-to-long v6, v0转换v0寄存器中的int型值为long型值存入v6,v7。</td></tr><tr><td>82</td><td>int-to-float vx, vy</td><td>转换vy寄存器中的int型值为float型值存入vx。</td><td>8206 - int-to-float v6, v0转换v0寄存器中的int型值为float型值存入v6。</td></tr><tr><td>83</td><td>int-to-double vx, vy</td><td>转换vy寄存器中的int型值为double型值存入vx,vx+1。</td><td>8306 - int-to-double v6, v0转换v0寄存器中的int型值为double型值存入v6,v7。</td></tr><tr><td>84</td><td>long-to-int vx, vy</td><td>转换vy,vy+1寄存器中的long型值为int型值存入vx。</td><td>8424 - long-to-int v4, v2转换v2,v3寄存器中的long型值为int型值存入v4。</td></tr><tr><td>85</td><td>long-to-float vx, vy</td><td>转换vy,vy+1寄存器中的long型值为float型值存入vx。</td><td>8510 - long-to-float v0, v1转换v1,v2寄存器中的long型值为float型值存入v0。</td></tr><tr><td>86</td><td>long-to-double vx, vy</td><td>转换vy,vy+1寄存器中的long型值为double型值存入vx,vx+1。</td><td>8610 - long-to-double v0, v1转换v1,vy2寄存器中的long型值为double型值存入v0,v1。</td></tr><tr><td>87</td><td>float-to-int vx, vy</td><td>转换vy寄存器中的float型值为int型值存入vx。</td><td>8730 - float-to-int v0, v3转换v3寄存器中的float型值为int型值存入v0。</td></tr><tr><td>88</td><td>float-to-long vx, vy</td><td>转换vy寄存器中的float型值为long型值存入vx,vx+1。</td><td>8830 - float-to-long v0, v3转换v3寄存器中的float型值为long型值存入v0,v1。</td></tr><tr><td>89</td><td>float-to-double vx, vy</td><td>转换vy寄存器中的float型值为double型值存入vx,vx+1。</td><td>8930 - float-to-double v0, v3转换v3寄存器中的float型值为double型值存入v0,v1。</td></tr><tr><td>8A</td><td>double-to-int vx, vy</td><td>转换vy,vy+1寄存器中的double型值为int型值存入vx。</td><td>8A40 - double-to-int v0, v4转换v4,v5寄存器中的double型值为int型值存入v0。</td></tr><tr><td>8B</td><td>double-to-long vx, vy</td><td>转换vy,vy+1寄存器中的double型值为long型值存入vx,vx+1。</td><td>8B40 - double-to-long v0, v4转换v4,v5寄存器中的double型值为long型值存入v0,v1。</td></tr><tr><td>8C</td><td>double-to-float vx, vy</td><td>转换vy,vy+1寄存器中的double型值为float型值存入vx。</td><td>8C40 - double-to-float v0, v4转换v4,v5寄存器中的double型值为float型值存入v0。</td></tr><tr><td>8D</td><td>int-to-byte vx, vy</td><td>转换vy寄存器中的int型值为byte型值存入vx。</td><td>8D00 - int-to-byte v0, v0转换v0寄存器中的int型值为byte型值存入v0。</td></tr><tr><td>8E</td><td>int-to-char vx, vy</td><td>转换vy寄存器中的int型值为char型值存入vx。</td><td>8E33 - int-to-char v3, v3转换v3寄存器中的int型值为char型值存入v3。</td></tr><tr><td>8F</td><td>int-to-short vx, vy</td><td>转换vy寄存器中的int型值为short型值存入vx。</td><td>8F00 - int-to-short v3, v0转换v0寄存器中的int型值为short型值存入v0。</td></tr><tr><td>90</td><td>add-int vx, vy, vz</td><td>计算vy + vz并将结果存入vx。</td><td>9000 0203 - add-int v0, v2, v3计算v2 + v3并将结果存入v0注4。</td></tr><tr><td>91</td><td>sub-int vx, vy, vz</td><td>计算vy - vz并将结果存入vx。</td><td>9100 0203 - sub-int v0, v2, v3计算v2 – v3并将结果存入v0。</td></tr><tr><td>92</td><td>mul-int vx, vy, vz</td><td>计算vy * vz并将结果存入vx。</td><td>9200 0203 - mul-int v0,v2,v3计算v2 * w3并将结果存入v0。</td></tr><tr><td>93</td><td>div-int vx, vy, vz</td><td>计算vy / vz并将结果存入vx。</td><td>9303 0001 - div-int v3, v0, v1计算v0 / v1并将结果存入v3。</td></tr><tr><td>94</td><td>rem-int vx, vy, vz</td><td>计算vy % vz并将结果存入vx。</td><td>9400 0203 - rem-int v0, v2, v3计算v3 % v2并将结果存入v0。</td></tr><tr><td>95</td><td>and-int vx, vy, vz</td><td>计算vy 与 vz并将结果存入vx。</td><td>9503 0001 - and-int v3, v0, v1计算v0 与 v1并将结果存入v3。</td></tr><tr><td>96</td><td>or-int vx, vy, vz</td><td>计算vy 或 vz并将结果存入vx。</td><td>9603 0001 - or-int v3, v0, v1计算v0 或 v1并将结果存入v3。</td></tr><tr><td>97</td><td>xor-int vx, vy, vz</td><td>计算vy 异或 vz并将结果存入vx。</td><td>9703 0001 - xor-int v3, v0, v1计算v0 异或 v1并将结果存入v3。</td></tr><tr><td>98</td><td>shl-int vx, vy, vz</td><td>左移vy，vz指定移动的位置，结果存入vx。</td><td>9802 0001 - shl-int v2, v0, v1以v1指定的位置左移v0，结果存入v2。</td></tr><tr><td>99</td><td>shr-int vx, vy, vz</td><td>右移vy，vz指定移动的位置，结果存入vx。</td><td>9902 0001 - shr-int v2, v0, v1以v1指定的位置右移v0，结果存入v2。</td></tr><tr><td>9A</td><td>ushr-int vx, vy, vz</td><td>无符号右移vy，vz指定移动的位置，结果存入vx。</td><td>9A02 0001 - ushr-int v2, v0, v1以v1指定的位置无符号右移v0，结果存入v2。</td></tr><tr><td>9B</td><td>add-long vx, vy, vz</td><td>计算vy,vy+1 + vz,vz+1并将结果存入vx,vx+1注1。</td><td>9B00 0305 - add-long v0, v3, v5计算v3,v4 + v5,v6并将结果存入v0,v1。</td></tr><tr><td>9C</td><td>sub-long vx, vy, vz</td><td>计算vy,vy+1 - vz,vz+1并将结果存入vx,vx+1注1。</td><td>9C00 0305 - sub-long v0, v3, v5计算v3,v4 - v5,v6并将结果存入v0,v1。</td></tr><tr><td>9D</td><td>mul-long vx, vy, vz</td><td>计算vy,vy+1 * vz,vz+1并将结果存入vx,vx+1注1。</td><td>9D00 0305 - mul-long v0, v3, v5计算v3,v4 * v5,v6并将结果存入v0,v1。</td></tr><tr><td>9E</td><td>div-long vx, vy, vz</td><td>计算vy,vy+1 / vz,vz+1并将结果存入vx,vx+1注1。</td><td>9E06 0002 - div-long v6, v0, v2计算v0,v1 / v2,v3并将结果存入v6,v7。</td></tr><tr><td>9F</td><td>rem-long vx, vy, vz</td><td>计算vy,vy+1 % vz,vz+1并将结果存入vx,vx+1注1。</td><td>9F06 0002 - rem-long v6, v0, v2计算v0,v1 % v2,v3并将结果存入v6,v7。</td></tr><tr><td>A0</td><td>and-long vx, vy, vz</td><td>计算vy,vy+1 与 vz,vz+1并将结果存入vx,vx+1注1。</td><td>A006 0002 - and-long v6, v0, v2计算v0,v1 与 v2,v3并将结果存入v6,v7。</td></tr><tr><td>A1</td><td>or-long vx, vy, vz</td><td>计算vy,vy+1 或 vz,vz+1并将结果存入vx,vx+1注1。</td><td>A106 0002 - or-long v6, v0, v2计算v0,v1 或 v2,v3并将结果存入v6,v7。</td></tr><tr><td>A2</td><td>xor-long vx, vy, vz</td><td>计算vy,vy+1 异或 vz,vz+1并将结果存入vx,vx+1注1。</td><td>A206 0002 - xor-long v6, v0, v2计算v0,v1 异或 v2,v3并将结果存入v6,v7。</td></tr><tr><td>A3</td><td>shl-long vx, vy, vz</td><td>左移vy,vy+1，vz指定移动的位置，结果存入vx,vx+1注1。</td><td>A302 0004 - shl-long v2, v0, v4以v4指定的位置左移v0,v1，结果存入v2,v3。</td></tr><tr><td>A4</td><td>shr-long vx, vy, vz</td><td>右移vy,vy+1，vz指定移动的位置，结果存入vx,vx+1注1。</td><td>A402 0004 - shr-long v2, v0, v4以v4指定的位置右移v0,v1，结果存入v2,v3。</td></tr><tr><td>A5</td><td>ushr-long vx, vy, vz</td><td>无符号右移vy,vy+1，vz指定移动的位置，结果存入vx,vx+1注1。</td><td>A502 0004 - ushr-long v2, v0, v4以v4指定的位置无符号右移v0,v1，结果存入v2,v3。</td></tr><tr><td>A6</td><td>add-float vx, vy, vz</td><td>计算vy + vz并将结果存入vx。</td><td>A600 0203 - add-float v0, v2, v3计算v2 + v3并将结果存入v0。</td></tr><tr><td>A7</td><td>sub-float vx, vy, vz</td><td>计算vy - vz并将结果存入vx。</td><td>A700 0203 - sub-float v0, v2, v3计算v2 - v3并将结果存入v0。</td></tr><tr><td>A8</td><td>mul-float vx, vy, vz</td><td>计算vy * vz并将结果存入vx。</td><td>A803 0001 - mul-float v3, v0, v1计算v0 * v1并将结果存入v3。</td></tr><tr><td>A9</td><td>div-float vx, vy, vz</td><td>计算vy / vz并将结果存入vx。</td><td>A903 0001 - div-float v3, v0, v1计算v0 / v1并将结果存入v3。</td></tr><tr><td>AA</td><td>rem-float vx, vy, vz</td><td>计算vy % vz并将结果存入vx。</td><td>AA03 0001 - rem-float v3, v0, v1计算v0 % v1并将结果存入v3。</td></tr><tr><td>AB</td><td>add-double vx, vy, vz</td><td>计算vy,vy+1 + vz,vz+1并将结果存入vx,vx+1注1。</td><td>AB00 0305 - add-double v0, v3, v5计算v3,v4 + v5,v6并将结果存入v0,v1。</td></tr><tr><td>AC</td><td>sub-double vx, vy, vz</td><td>计算vy,vy+1 - vz,vz+1并将结果存入vx,vx+1注1。</td><td>AC00 0305 - sub-double v0, v3, v5计算v3,v4 - v5,v6并将结果存入v0,v1。</td></tr><tr><td>AD</td><td>mul-double vx, vy, vz</td><td>计算vy,vy+1 * vz,vz+1并将结果存入vx,vx+1注1。</td><td>AD06 0002 - mul-double v6, v0, v2计算v0,v1 * v2,v3并将结果存入v6,v7。</td></tr><tr><td>AE</td><td>div-double vx, vy, vz</td><td>计算vy,vy+1 / vz,vz+1并将结果存入vx,vx+1注1。</td><td>AE06 0002 - div-double v6, v0, v2计算v0,v1 / v2,v3并将结果存入v6,v7。</td></tr><tr><td>AF</td><td>rem-double vx, vy, vz</td><td>计算vy,vy+1 % vz,vz+1并将结果存入vx,vx+1注1。</td><td>AF06 0002 - rem-double v6, v0, v2计算v0,v1 % v2,v3并将结果存入v6,v7。</td></tr><tr><td>B0</td><td>add-int/2addr vx, vy</td><td>计算vx + vy并将结果存入vx。</td><td>B010 - add-int/2addr v0,v1计算v0 + v1并将结果存入v0。</td></tr><tr><td>B1</td><td>sub-int/2addr vx, vy</td><td>计算vx - vy并将结果存入vx。</td><td>B140 - sub-int/2addr v0, v4计算v0 – v4并将结果存入v0。</td></tr><tr><td>B2</td><td>mul-int/2addr vx, vy</td><td>计算vx * vy并将结果存入vx。</td><td>B210 - mul-int/2addr v0, v1计算v0 * v1并将结果存入v0。</td></tr><tr><td>B3</td><td>div-int/2addr vx, vy</td><td>计算vx / vy并将结果存入vx。</td><td>B310 - div-int/2addr v0, v1计算v0 / v1并将结果存入v0。</td></tr><tr><td>B4</td><td>rem-int/2addr vx, vy</td><td>计算vx % vy并将结果存入vx。</td><td>B410 - rem-int/2addr v0, v1计算v0 % v1并将结果存入v0。</td></tr><tr><td>B5</td><td>and-int/2addr vx, vy</td><td>计算vx 与 vy并将结果存入vx。</td><td>B510 - and-int/2addr v0, v1计算v0 与 v1并将结果存入v0。</td></tr><tr><td>B6</td><td>or-int/2addr vx, vy</td><td>计算vx 或 vy并将结果存入vx。</td><td>B610 - or-int/2addr v0, v1计算v0 或 v1并将结果存入v0。</td></tr><tr><td>B7</td><td>xor-int/2addr vx, vy</td><td>计算vx 异或 vy并将结果存入vx。</td><td>B710 - xor-int/2addr v0, v1计算v0 异或 v1并将结果存入v0。</td></tr><tr><td>B8</td><td>shl-int/2addr vx, vy</td><td>左移vx，vy指定移动的位置，并将结果存入vx。</td><td>B810 - shl-int/2addr v0, v1以v1指定的位置左移v0，结果存入v0。</td></tr><tr><td>B9</td><td>shr-int/2addr vx, vy</td><td>右移vx，vy指定移动的位置，并将结果存入vx。</td><td>B910 - shr-int/2addr v0, v1以v1指定的位置右移v0，结果存入v0。</td></tr><tr><td>BA</td><td>ushr-int/2addr vx, vy</td><td>无符号右移vx，vy指定移动的位置，并将结果存入vx。</td><td>BA10 - ushr-int/2addr v0, v1以v1指定的位置无符号右移v0，结果存入v0。</td></tr><tr><td>BB</td><td>add-long/2addr vx, vy</td><td>计算vx,vx+1 + vy,vy+1并将结果存入vx,vx+1注1。</td><td>BB20 - add-long/2addr v0, v2计算v0,v1 + v2,v3并将结果存入v0,v1。</td></tr><tr><td>BC</td><td>sub-long/2addr vx, vy</td><td>计算vx,vx+1 - vy,vy+1并将结果存入vx,vx+1注1。</td><td>BC70 - sub-long/2addr v0, v7计算v0,v1 - v7,v8并将结果存入v0,v1。</td></tr><tr><td>BD</td><td>mul-long/2addr vx, vy</td><td>计算vx,vx+1 * vy,vy+1并将结果存入vx,vx+1注1。</td><td>BD70 - mul-long/2addr v0, v7计算v0,v1 * v7,v8并将结果存入v0,v1。</td></tr><tr><td>BE</td><td>div-long/2addr vx, vy</td><td>计算vx,vx+1 / vy,vy+1并将结果存入vx,vx+1注1。</td><td>BE20 - div-long/2addr v0, v2计算v0,v1 / v2,v3并将结果存入v0,v1。</td></tr><tr><td>BF</td><td>rem-long/2addr vx, vy</td><td>计算vx,vx+1 % vy,vy+1并将结果存入vx,vx+1注1。</td><td>BF20 - rem-long/2addr v0, v2计算v0,v1 % v2,v3并将结果存入v0,v1。</td></tr><tr><td>C0</td><td>and-long/2addr vx, vy</td><td>计算vx,vx+1 与 vy,vy+1并将结果存入vx,vx+1注1。</td><td>C020 - and-long/2addr v0, v2计算v0,v1 与 v2,v3并将结果存入v0,v1。</td></tr><tr><td>C1</td><td>or-long/2addr vx, vy</td><td>计算vx,vx+1 或 vy,vy+1并将结果存入vx,vx+1注1。</td><td>C120 - or-long/2addr v0, v2计算v0,v1 或 v2,v3并将结果存入v0,v1。</td></tr><tr><td>C2</td><td>xor-long/2addr vx, vy</td><td>计算vx,vx+1 异或 vy,vy+1并将结果存入vx,vx+1注1。</td><td>C220 - xor-long/2addr v0, v2计算v0,v1 异或 v2,v3并将结果存入v0,v1。</td></tr><tr><td>C3</td><td>shl-long/2addr vx, vy</td><td>左移vx,vx+1，vy指定移动的位置，并将结果存入vx,vx+1。</td><td>C320 - shl-long/2addr v0, v2以v2指定的位置左移v0,v1，结果存入v0,v1。</td></tr><tr><td>C4</td><td>shr-long/2addr vx, vy</td><td>右移vx,vx+1，vy指定移动的位置，并将结果存入vx,vx+1。</td><td>C420 - shr-long/2addr v0, v2以v2指定的位置右移v0,v1，结果存入v0,v1。</td></tr><tr><td>C5</td><td>ushr-long/2addr vx, vy</td><td>无符号右移vx,vx+1，vy指定移动的位置，并将结果存入vx,vx+1。</td><td>C520 - ushr-long/2addr v0, v2以v2指定的位置无符号右移v0,v1，结果存入v0,v1。</td></tr><tr><td>C6</td><td>add-float/2addr vx, vy</td><td>计算vx + vy并将结果存入vx。</td><td>C640 - add-float/2addr v0,v4计算v0 + v4并将结果存入v0。</td></tr><tr><td>C7</td><td>sub-float/2addr vx, vy</td><td>计算vx - vy并将结果存入vx。</td><td>C740 - sub-float/2addr v0,v4计算v0 - v4并将结果存入v0。</td></tr><tr><td>C8</td><td>mul-float/2addr vx, vy</td><td>计算vx * vy并将结果存入vx。</td><td>C810 - mul-float/2addr v0, v1计算v0 * v1并将结果存入v0。</td></tr><tr><td>C9</td><td>div-float/2addr vx, vy</td><td>计算vx / vy并将结果存入vx。</td><td>C910 - div-float/2addr v0, v1计算v0 / v1并将结果存入v0。</td></tr><tr><td>CA</td><td>rem-float/2addr vx, vy</td><td>计算vx % vy并将结果存入vx。</td><td>CA10 - rem-float/2addr v0, v1计算v0 % v1并将结果存入v0。</td></tr><tr><td>CB</td><td>add-double/2addr vx, vy</td><td>计算vx,vx+1 + vy,vy+1并将结果存入vx,vx+1注1。</td><td>CB70 - add-double/2addr v0, v7计算v0,v1 + v7,v8并将结果存入v0,v1。</td></tr><tr><td>CC</td><td>sub-double/2addr vx, vy</td><td>计算vx,vx+1 - vy,vy+1并将结果存入vx,vx+1注1。</td><td>CC70 - sub-double/2addr v0, v7计算v0,v1 - v7,v8并将结果存入v0,v1。</td></tr><tr><td>CD</td><td>mul-double/2addr vx, vy</td><td>计算vx,vx+1 * vy,vy+1并将结果存入vx,vx+1注1。</td><td>CD20 - mul-double/2addr v0, v2计算v0,v1 * v2,v3并将结果存入v0,v1。</td></tr><tr><td>CE</td><td>div-double/2addr vx, vy</td><td>计算vx,vx+1 / vy,vy+1并将结果存入vx,vx+1注1。</td><td>CE20 - div-double/2addr v0, v2计算v0,v1 / v2,v3并将结果存入v0,v1。</td></tr><tr><td>CF</td><td>rem-double/2addr vx, vy</td><td>计算vx,vx+1 % vy,vy+1并将结果存入vx,vx+1注1。</td><td>CF20 - rem-double/2addr v0, v2计算v0,v1 % v2,v3并将结果存入v0,v1。</td></tr><tr><td>D0</td><td>add-int/lit16 vx, vy, lit16</td><td>计算vy + lit16并将结果存入vx。</td><td>D001 D204 - add-int/lit16 v1, v0, #int 1234 // #04d2计算v0 + 1234并将结果存入v1。</td></tr><tr><td>D1</td><td>sub-int/lit16 vx, vy, lit16</td><td>计算vy - lit16并将结果存入vx。</td><td>D101 D204 - sub-int/lit16 v1, v0, #int 1234 // #04d2计算v0 - 1234并将结果存入v1。</td></tr><tr><td>D2</td><td>mul-int/lit16 vx, vy, lit16</td><td>计算vy * lit16并将结果存入vx。</td><td>D201 D204 - mul-int/lit16 v1, v0, #int 1234 // #04d2计算v0 * 1234并将结果存入v1。</td></tr><tr><td>D3</td><td>div-int/lit16 vx, vy, lit16</td><td>计算vy / lit16并将结果存入vx。</td><td>D301 D204 - div-int/lit16 v1, v0, #int 1234 // #04d2计算v0 / 1234并将结果存入v1。</td></tr><tr><td>D4</td><td>rem-int/lit16 vx, vy, lit16</td><td>计算vy % lit16并将结果存入vx。</td><td>D401 D204 - rem-int/lit16 v1, v0, #int 1234 // #04d2计算v0 % 1234并将结果存入v1。</td></tr><tr><td>D5</td><td>and-int/lit16 vx, vy, lit16</td><td>计算vy 与 lit16并将结果存入vx。</td><td>D501 D204 - and-int/lit16 v1, v0, #int 1234 // #04d2计算v0 与 1234并将结果存入v1。</td></tr><tr><td>D6</td><td>or-int/lit16 vx, vy, lit16</td><td>计算vy 或 lit16并将结果存入vx。</td><td>D601 D204 - or-int/lit16 v1, v0, #int 1234 // #04d2计算v0 或 1234并将结果存入v1。</td></tr><tr><td>D7</td><td>xor-int/lit16 vx, vy, lit16</td><td>计算vy 异或 lit16并将结果存入vx。</td><td>D701 D204 - xor-int/lit16 v1, v0, #int 1234 // #04d2计算v0 异或 1234并将结果存入v1。</td></tr><tr><td>D8</td><td>add-int/lit8 vx, vy, lit8</td><td>计算vy + lit8并将结果存入vx。</td><td>D800 0201 - add-int/lit8 v0,v2, #int1计算v2 + 1并将结果存入v0。</td></tr><tr><td>D9</td><td>sub-int/lit8 vx, vy, lit8</td><td>计算vy - lit8并将结果存入vx。</td><td>D900 0201 - sub-int/lit8 v0,v2, #int1计算v2 - 1并将结果存入v0。</td></tr><tr><td>DA</td><td>mul-int/lit8 vx, vy, lit8</td><td>计算vy * lit8并将结果存入vx。</td><td>DA00 0002 - mul-int/lit8 v0,v0, #int2计算v0 * 2并将结果存入v0。</td></tr><tr><td>DB</td><td>div-int/lit8 vx, vy, lit8</td><td>计算vy / lit8并将结果存入vx。</td><td>DB00 0203 - mul-int/lit8 v0,v2, #int3计算v2 / 3并将结果存入v0。</td></tr><tr><td>DC</td><td>rem-int/lit8 vx, vy, lit8</td><td>计算vy % lit8并将结果存入vx。</td><td>DC00 0203 - rem-int/lit8 v0,v2, #int3计算v2 % 3并将结果存入v0。</td></tr><tr><td>DD</td><td>and-int/lit8 vx, vy, lit8</td><td>计算vy 与 lit8并将结果存入vx。</td><td>DD00 0203 - and-int/lit8 v0,v2, #int3计算v2 与 3并将结果存入v0。</td></tr><tr><td>DE</td><td>or-int/lit8 vx, vy, lit8</td><td>计算vy 或 lit8并将结果存入vx。</td><td>DE00 0203 - or-int/lit8 v0, v2, #int 3计算v2 或 3并将结果存入v0。</td></tr><tr><td>DF</td><td>xor-int/lit8 vx, vy, lit8</td><td>计算vy异或lit8并将结果存入vx。</td><td>DF00 0203 | 0008: xor-int/lit8 v0, v2, #int 3计算v2 异或 3并将结果存入v0。</td></tr><tr><td>E0</td><td>shl-int/lit8 vx, vy, lit8</td><td>左移vy，lit8指定移动的位置，并将结果存入vx。</td><td>E001 0001 - shl-int/lit8 v1, v0, #int 1将v0左移1位，结果存入v1。</td></tr><tr><td>E1</td><td>shr-int/lit8 vx, vy, lit8</td><td>右移vy，lit8指定移动的位置，并将结果存入vx。</td><td>E101 0001 - shr-int/lit8 v1, v0, #int 1将v0右移1位，结果存入v1。</td></tr><tr><td>E2</td><td>ushr-int/lit8 vx, vy, lit8</td><td>无符号右移vy，lit8指定移动的位置，并将结果存入vx。</td><td>E201 0001 - ushr-int/lit8 v1, v0, #int 1将v0无符号右移1位，结果存入v1。</td></tr><tr><td>E3</td><td>unused_E3</td><td>未使用</td><td></td></tr><tr><td>E4</td><td>unused_E4</td><td>未使用</td><td></td></tr><tr><td>E5</td><td>unused_E5</td><td>未使用</td><td></td></tr><tr><td>E6</td><td>unused_E6</td><td>未使用</td><td></td></tr><tr><td>E7</td><td>unused_E7</td><td>未使用</td><td></td></tr><tr><td>E8</td><td>unused_E8</td><td>未使用</td><td></td></tr><tr><td>E9</td><td>unused_E9</td><td>未使用</td><td></td></tr><tr><td>EA</td><td>unused_EA</td><td>未使用</td><td></td></tr><tr><td>EB</td><td>unused_EB</td><td>未使用</td><td></td></tr><tr><td>EC</td><td>unused_EC</td><td>未使用</td><td></td></tr><tr><td>ED</td><td>unused_ED</td><td>未使用</td><td></td></tr><tr><td>EE</td><td>execute-inline {<em>参数</em>}, <em>内联**ID</em></td><td>根据<em>内联*</em>ID*注6执行内联方法。</td><td>EE20 0300 0100 - execute-inline {v1, v0}, inline #0003执行内联方法#3，参数v1,v0，其中参数v1为”this”的实例，v0是方法的参数。</td></tr><tr><td>EF</td><td>unused_EF</td><td>未使用</td><td></td></tr><tr><td>F0</td><td>invoke-direct-empty</td><td>用于空方法的占位符，如Object.<init>。这相当于正常执行了nop指令注6。</init></td><td>F010 F608 0000 - invoke-direct-empty {v0}, Ljava/lang/Object;.<init>:()V // method@08f6替代空方法java/lang/Object;<init>。</init></init></td></tr><tr><td>F1</td><td>unused_F1</td><td>未使用</td><td></td></tr><tr><td>F2</td><td>iget-quick vx, vy, <em>偏移量</em></td><td>获取vy寄存器中实例指向+<em>偏移位置</em>的数据区的值，存入vx注6。</td><td>F221 1000 - iget-quick v1, v2, [obj+0010]获取v2寄存器中的实例指向+10H位置的数据区的值，存入v1。</td></tr><tr><td>F3</td><td>iget-wide-quick vx, vy, <em>偏移量</em></td><td>获取vy寄存器中实例指向+<em>偏移位置</em>的数据区的值，存入vx,vx+1注6。</td><td>F364 3001 - iget-wide-quick v4, v6, [obj+0130]获取v6寄存器中的实例指向+130H位置的数据区的值，存入v4,v5。</td></tr><tr><td>F4</td><td>iget-object-quick vx, vy, <em>偏移量</em></td><td>获取vy寄存器中实例指向+<em>偏移位置</em>的数据区的对象引用，存入vx注6。</td><td>F431 0C00 - iget-object-quick v1, v3, [obj+000c]获取v3寄存器中的实例指向+0CH位置的数据区的对象引用，存入v1。</td></tr><tr><td>F5</td><td>iput-quick vx, vy, <em>偏移量</em></td><td>将vx寄存器中的值存入vy寄存器中的实例指向+<em>偏移位置</em>的数据区注6。</td><td>F521 1000 - iput-quick v1, v2, [obj+0010]将v1寄存器中的值存入v2寄存器中的实例指向+10H位置的数据区。</td></tr><tr><td>F6</td><td>iput-wide-quick vx, vy, <em>偏移量</em></td><td>将vx,vx+1寄存器中的值存入vy寄存器中的实例指向+<em>偏移位置</em>的数据区注6。</td><td>F652 7001 - iput-wide-quick v2, v5, [obj+0170]将v2,v3寄存器中的值存入v5寄存器中的实例指向+170H位置的数据区。</td></tr><tr><td>F7</td><td>iput-object-quick vx, vy, <em>偏移量</em></td><td>将vx寄存器中的对象引用存入vy寄存器中的实例指向+<em>偏移位置</em>的数据区注6。</td><td>F701 4C00 - iput-object-quick v1, v0, [obj+004c]将v1寄存器中的对象引用存入v0寄存器中的实例指向+4CH位置的数据区。</td></tr><tr><td>F8</td><td>invoke-virtual-quick {<em>参数</em>}, <em>虚拟表偏移量</em></td><td>调用虚拟方法，使用目标对象虚拟表注6。</td><td>F820 B800 CF00 - invoke-virtual-quick {v15, v12}, vtable #00b8调用虚拟方法，目标对象的实例指向位于v15寄存器，方法位于虚拟表#B8条目，方法所需的参数位于v12。</td></tr><tr><td>F9</td><td>invoke-virtual-quick/range {<em>参数范围</em>}, <em>虚拟表偏移量</em></td><td>调用虚拟方法，使用目标对象虚拟表注6。</td><td>F906 1800 0000 - invoke-virtual-quick/range {v0..v5},vtable #0018调用虚拟方法，目标对象的实例指向位于v0寄存器，方法位于虚拟表#18H条目，方法所需的参数位于v1..v5。</td></tr><tr><td>FA</td><td>invoke-super-quick {<em>参数</em>}, <em>虚拟表偏移量</em></td><td>调用父类虚拟方法，使用目标对象的直接父类的虚拟表注6。</td><td>FA40 8100 3254 - invoke-super-quick {v2, v3, v4, v5}, vtable #0081调用父类虚拟方法，目标对象的实例指向位于v2寄存器，方法位于虚拟表#81H条目，方法所需的参数位于v3,v4,v5。</td></tr><tr><td>FB</td><td>invoke-super-quick/range {<em>参数范围</em>}, <em>虚拟表偏移量</em></td><td>调用父类虚拟方法，使用目标对象的直接父类的虚拟表注6。</td><td>F906 1B00 0000 - invoke-super-quick/range {v0..v5}, vtable #001b调用父类虚拟方法，目标对象的实例指向位于v0寄存器，方法位于虚拟表#1B条目，方法所需的参数位于v1..v5。</td></tr><tr><td>FC</td><td>unused_FC</td><td>未使用</td><td></td></tr><tr><td>FD</td><td>unused_FD</td><td>未使用</td><td></td></tr><tr><td>FE</td><td>unused_FE</td><td>未使用</td><td></td></tr><tr><td>FF</td><td>unused_FF</td><td>未使用</td><td></td></tr></tbody></table><p>注1：  Double和long值占用两个寄存器。（例：在vy地址上的值位于vy,vy+1寄存器）</p><p>注2：  偏移量可以是正或负，从指令起始字节起计算偏移量。偏移量在（2字节每1偏移量递增/递减）时解释执行。负偏移量用二进制补码格式存储。偏移量当前位置是指令起始字节。</p><p>注3：  比较操作，如果第一个操作数大于第二个操作数返回正值；如果两者相等，返回0；如果第一个操作数小于第二个操作数，返回负值。</p><p>注4：  正常使用没见到过的，从<a href="http://code.google.com/android/reference/dalvik/bytecode/Opcodes.html" target="_blank" rel="noopener">Android opcode constant list</a>引入。</p><p>注5：  调用参数表的编译比较诡异。如果参数的数量大于4并且%4=1，第5（第9或其他%4=1的）个参数将编译在指令字节的下一个字节的4个最低位。奇怪的是，有一种情况不使用这种编译：方法有4个参数但用于编译单一参数，指令字节的下一个字节的4个最低位空置，将会编译为40而不是04。</p><p>注6：  这是一个不安全的指令，仅适用于ODEX文件。</p><p>参考链接：<a href="https://www.cnblogs.com/liweis/p/4653496.html" target="_blank" rel="noopener">https://www.cnblogs.com/liweis/p/4653496.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;smali语言是Davlik虚拟机为自己专门设计的一套指令集，并且制定了自己的指令格式与调用规范。我们将Dalvik指令集组成的代码称为Dalvik汇编代码或者叫smali代码， Dalvik虚拟机是基于寄存器架构，任何的操作都要通过寄存器来完成，其寄存器有两种命名方法，分别为v命名法与p命名法。&lt;/p&gt;
&lt;h2 id=&quot;smali关键字说明&quot;&gt;&lt;a href=&quot;#smali关键字说明&quot; class=&quot;headerlink&quot; title=&quot;smali关键字说明&quot;&gt;&lt;/a&gt;smali关键字说明&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;关键字&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;.class&lt;/td&gt;
&lt;td&gt;.class Lcom/test/Utils;&lt;/td&gt;
&lt;td&gt;说明当前这个smali属于哪个类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.super&lt;/td&gt;
&lt;td&gt;.super Ljava/lang/Object;&lt;/td&gt;
&lt;td&gt;说明当前这个类的父类是谁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.source&lt;/td&gt;
&lt;td&gt;.source “Utils.java”&lt;/td&gt;
&lt;td&gt;说明这个类的源文件名字&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="https://marming19.github.io/categories/Android%E9%80%86%E5%90%91/"/>
    
    
    <category term="Android逆向" scheme="https://marming19.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
    <category term="smali" scheme="https://marming19.github.io/tags/smali/"/>
    
    <category term="java汇编" scheme="https://marming19.github.io/tags/java%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>记录下Windows使用VMware搭建MacOS系统的过程</title>
    <link href="https://marming19.github.io/2020/06/19/VMWareInstallMacOS/"/>
    <id>https://marming19.github.io/2020/06/19/VMWareInstallMacOS/</id>
    <published>2020-06-19T07:25:11.000Z</published>
    <updated>2020-06-27T14:57:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><ul><li><p>VMware</p><p>下载地址：<a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html</a></p></li><li><p>MacOS镜像(dmg)</p><p>下载地址1：<a href="https://blog.daliansky.net/" target="_blank" rel="noopener">https://blog.daliansky.net/</a> （黑果小兵）</p><p>下载地址2：<a href="https://www.applex.net/pages/macos/" target="_blank" rel="noopener">https://www.applex.net/pages/macos/</a> （极限苹果）</p></li><li><p>unlocker </p><p>下载地址：<a href="https://unlocker.en.softonic.com/" target="_blank" rel="noopener">https://unlocker.en.softonic.com/</a></p><a id="more"></a></li><li><p>Transmac工具</p><p>下载地址：<a href="https://www.sdbeta.com/wg/2019/0122/228208.html" target="_blank" rel="noopener">https://www.sdbeta.com/wg/2019/0122/228208.html</a></p></li><li><p>16G U盘 (用于制作系统MacOS系统)</p></li></ul><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>安装VMware这里不详细说。</p><h3 id="使用unlocker解锁VMware"><a href="#使用unlocker解锁VMware" class="headerlink" title="使用unlocker解锁VMware"></a>使用unlocker解锁VMware</h3><p>第一步打开任务管理器</p><p><img src="/2020/06/19/VMWareInstallMacOS/image-1.png" alt="image-1"></p><p>第二步切换到服务窗口，关闭所有VMWare的服务。</p><p><img src="/2020/06/19/VMWareInstallMacOS/image-2.png" alt="image-2"></p><p>第三步管理员身份运行unlocker工具，解锁虚拟机</p><p><img src="/2020/06/19/VMWareInstallMacOS/image-3.png" alt="image-3"></p><p>第四步打开虚拟机确认是否解锁成功，如果在新建虚拟机时，选择操作系统中存在apple mac OS选项，说明解锁成功。</p><p><img src="/2020/06/19/VMWareInstallMacOS/image-4.png" alt="image-4"></p><h3 id="Transmac工具制作镜像"><a href="#Transmac工具制作镜像" class="headerlink" title="Transmac工具制作镜像"></a>Transmac工具制作镜像</h3><p>打开工具选择要制作镜像的U盘</p><p><img src="/2020/06/19/VMWareInstallMacOS/image-5.png" alt="image-5"></p><p>修改U盘为Mac格式的分区</p><p><img src="/2020/06/19/VMWareInstallMacOS/image-6.png" alt="image-6"></p><p>烧制镜像</p><p><img src="/2020/06/19/VMWareInstallMacOS/image-7.png" alt="image-7"></p><p>选择下载好的dmg文件</p><p><img src="/2020/06/19/VMWareInstallMacOS/image-8.png" alt="image-8"></p><p><img src="/2020/06/19/VMWareInstallMacOS/image-9.png" alt="image-9"></p><p>进度条走完就制作完成了。</p><h3 id="VMWare设置U盘制作系统"><a href="#VMWare设置U盘制作系统" class="headerlink" title="VMWare设置U盘制作系统"></a>VMWare设置U盘制作系统</h3><p>创建完虚拟机，首先要去虚拟机安装目录下修改配置文件如下</p><p><img src="/2020/06/19/VMWareInstallMacOS/image-10.png" alt="image-10"></p><p>编辑虚拟机，添加一个新的硬盘</p><p><img src="/2020/06/19/VMWareInstallMacOS/image-11.png" alt="image-11"></p><img src="/2020/06/19/VMWareInstallMacOS/image-12.png" alt="image-12" style="zoom:200%;"><p>这里注意下选择使用物理磁盘</p><img src="/2020/06/19/VMWareInstallMacOS/image-13.png" alt="image-13" style="zoom:200%;"><p>选择U盘</p><img src="/2020/06/19/VMWareInstallMacOS/image-14.png" alt="image-14" style="zoom:200%;"><p>当完成后就发现虚拟机直接使用新建硬盘进行启动。</p><p><img src="/2020/06/19/VMWareInstallMacOS/image-15.png" alt="image-15"></p><p>到此设置完成，后面的安装过程看下面这个链接就可以</p><p><a href="https://www.jianshu.com/p/a04ddf269882" target="_blank" rel="noopener">https://www.jianshu.com/p/a04ddf269882</a></p><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><p>1.使用dmg2iso、dmg2img 工具将dmg镜像转换程iso镜像，实测没有卵用。<br>2.使用软碟通将dmg文件转换成iso镜像，也是没有用。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;工具准备&quot;&gt;&lt;a href=&quot;#工具准备&quot; class=&quot;headerlink&quot; title=&quot;工具准备&quot;&gt;&lt;/a&gt;工具准备&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;VMware&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MacOS镜像(dmg)&lt;/p&gt;
&lt;p&gt;下载地址1：&lt;a href=&quot;https://blog.daliansky.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.daliansky.net/&lt;/a&gt; （黑果小兵）&lt;/p&gt;
&lt;p&gt;下载地址2：&lt;a href=&quot;https://www.applex.net/pages/macos/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.applex.net/pages/macos/&lt;/a&gt; （极限苹果）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;unlocker &lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://unlocker.en.softonic.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://unlocker.en.softonic.com/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="其它" scheme="https://marming19.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    
    <category term="MacOS" scheme="https://marming19.github.io/tags/MacOS/"/>
    
    <category term="VMware" scheme="https://marming19.github.io/tags/VMware/"/>
    
  </entry>
  
</feed>
